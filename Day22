
## Day-22.md
```markdown
# Daily Diary - Day 22

## Lambda Expressions

### Today's Topics
- Lambda Expression Syntax
- Functional Interfaces
- Method References
- Lambda with Collections
- Built-in Functional Interfaces

### Practical Work
- Converted anonymous classes to lambdas
- Used lambda with forEach
- Created custom functional interfaces
- Practiced method references
- Used Stream API with lambdas

### Code Example
```java
import java.util.*;
import java.util.function.*;

// Custom functional interface
@FunctionalInterface
interface Calculator {
    int operate(int a, int b);
}

@FunctionalInterface
interface Greeter {
    void greet(String name);
}

public class LambdaDemo {
    public static void main(String[] args) {
        // Basic lambda expressions
        basicLambdaExamples();
        
        // Lambda with collections
        lambdaWithCollections();
        
        // Method references
        methodReferenceExamples();
        
        // Built-in functional interfaces
        builtInFunctionalInterfaces();
    }
    
    public static void basicLambdaExamples() {
        System.out.println("=== Basic Lambda Examples ===");
        
        // Traditional way using anonymous class
        Calculator addTraditional = new Calculator() {
            @Override
            public int operate(int a, int b) {
                return a + b;
            }
        };
        
        // Lambda expression way
        Calculator add = (a, b) -> a + b;
        Calculator multiply = (a, b) -> a * b;
        Calculator subtract = (a, b) -> a - b;
        
        System.out.println("Addition: " + add.operate(10, 5));
        System.out.println("Multiplication: " + multiply.operate(10, 5));
        System.out.println("Subtraction: " + subtract.operate(10, 5));
        
        // Lambda with multiple parameters and body
        Calculator complexOperation = (a, b) -> {
            int result = a * a + b * b;
            return result;
        };
        System.out.println("Complex operation: " + complexOperation.operate(3, 4));
        
        // Lambda with no parameters (using Runnable)
        Runnable helloTask = () -> System.out.println("Hello from lambda!");
        helloTask.run();
        
        // Lambda with one parameter
        Greeter formalGreeter = name -> System.out.println("Good day, " + name);
        Greeter casualGreeter = name -> System.out.println("Hey " + name + "!");
        
        formalGreeter.greet("Alice");
        casualGreeter.greet("Bob");
    }
    
    public static void lambdaWithCollections() {
        System.out.println("\n=== Lambda with Collections ===");
        
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Diana", "Eve");
        
        // Traditional for loop
        System.out.println("Traditional for loop:");
        for (String name : names) {
            System.out.println(name);
        }
        
        // Using forEach with lambda
        System.out.println("\nUsing forEach with lambda:");
        names.forEach(name -> System.out.println(name));
        
        // Using method reference
        System.out.println("\nUsing method reference:");
        names.forEach(System.out::println);
        
        // Filtering with lambda (using Stream API)
        System.out.println("\nNames starting with 'A':");
        names.stream()
             .filter(name -> name.startsWith("A"))
             .forEach(System.out::println);
             
        // Sorting with lambda
        System.out.println("\nSorted names by length:");
        names.stream()
             .sorted((name1, name2) -> Integer.compare(name1.length(), name2.length()))
             .forEach(System.out::println);
    }
    
    public static void methodReferenceExamples() {
        System.out.println("\n=== Method Reference Examples ===");
        
        List<String> words = Arrays.asList("hello", "world", "java", "lambda");
        
        // Static method reference
        System.out.println("Using static method reference:");
        words.forEach(System.out::println);
        
        // Instance method reference
        System.out.println("Using instance method reference:");
        words.forEach(String::toUpperCase);
        
        // Arbitrary object method reference
        System.out.println("Uppercase words:");
        words.stream()
             .map(String::toUpperCase)
             .forEach(System.out::println);
             
        // Constructor reference
        System.out.println("Creating new list:");
        List<String> upperCaseWords = words.stream()
                                          .map(String::toUpperCase)
                                          .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
        upperCaseWords.forEach(System.out::println);
    }
    
    public static void builtInFunctionalInterfaces() {
        System.out.println("\n=== Built-in Functional Interfaces ===");
        
        // Predicate - tests a condition
        Predicate<Integer> isEven = num -> num % 2 == 0;
        Predicate<String> isLong = str -> str.length() > 5;
        
        System.out.println("Is 10 even? " + isEven.test(10));
        System.out.println("Is 'Hello' long? " + isLong.test("Hello"));
        
        // Function - transforms input to output
        Function<String, Integer> stringLength = str -> str.length();
        Function<Integer, Integer> square = num -> num * num;
        
        System.out.println("Length of 'Java': " + stringLength.apply("Java"));
        System.out.println("Square of 5: " + square.apply(5));
        
        // Consumer - accepts input, returns nothing
        Consumer<String> printer = str -> System.out.println("Printing: " + str);
        printer.accept("Hello Consumer!");
        
        // Supplier - provides values
        Supplier<Double> randomSupplier = () -> Math.random();
        System.out.println("Random number: " + randomSupplier.get());
        
        // BinaryOperator - operates on two same types
        BinaryOperator<Integer> maxOperator = (a, b) -> a > b ? a : b;
        System.out.println("Max of 10 and 20: " + maxOperator.apply(10, 20));
        
        // Using multiple functional interfaces together
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        System.out.println("Even squares:");
        numbers.stream()
               .filter(isEven)                    // Predicate
               .map(square)                       // Function  
               .forEach(System.out::println);     // Consumer
    }
}
